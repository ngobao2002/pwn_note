Đây là bài toán thứ ba trên pwnable.tw, độ khó đã bắt đầu tăng lên, thử thách việc khai thác lỗ hổng trên một chương trình thực tế. Lỗ hổng bắt nguồn từ Netatalk, một chương trình máy chủ giao thức AFP của Apple mã nguồn mở. Lỗ hổng này được phát hiện lần đầu vào năm 2018 và được trình diễn khai thác 1-day tại HITCON Quals năm 2019.
#### Note:
Netatalk là một daemon mã nguồn mở (open-source) dành cho các hệ thống Unix-like hoặc Linux, dùng để triển khai Apple Filing Protocol (AFP). Nó cho phép các máy chủ không phải của Apple (như Linux hoặc BSD) hoạt động như một máy chủ chia sẻ file dành cho các thiết bị Macintosh (Mac). Cụ thể, Netatalk giúp chia sẻ file qua mạng giữa các hệ thống POSIX-compliant (như Linux) và máy Mac, thay thế cho các giao thức như SMB hoặc NFS trong môi trường Apple.

Ví dụ, bạn có thể sử dụng Netatalk để mount và truy cập thư mục chia sẻ từ máy Linux lên máy Mac một cách liền mạch, hỗ trợ các tính năng như chia sẻ file, in ấn và quản lý quyền truy cập. Nó thường được cài đặt trên các máy chủ NAS hoặc server để tích hợp với hệ sinh thái Apple.

Theo tài liệu tham khảo, phương pháp khở động máy chủ:
```Bash
LD_PRELOAD=./libc-2.27.so LD_LIBRARY_PATH=./ ./afpd -d -F ./afp.conf
```
Độ khó của bài đã tăng lên với việc đã bật hết tất cả cơ chế bảo vệ
![[Pasted image 20250907162012.png]]

Vì đây là 1 bài 1 day theo gợi ý của đề bài đây là 1 bài 1day => nên chúng ta có thể tìm hiểu được lỗi bảo mật xảy ra khi tràn 1 trường trong struct khi thực hiện memcpy.
Link download sourcecode: https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/
#### Quy trình hoạt động của máy chủ
Sau khi client thiết lập kết nối, máy chủ sẽ **fork** một tiến trình con để tương tác với client. Tiến trình con trước tiên đọc **header DSI** từ phiên TCP vào cấu trúc `dsi->header`, sau đó đọc nội dung **payload DSI** và đặt nó vào bộ đệm `buf` được trỏ bởi `dsi->commands`. Tiến trình con sau đó gọi `dsi_opensession` để xử lý thông tin phiên trong `commands`, rồi gọi `dsi_stream_receive` để tiếp tục đọc tin nhắn từ kết nối hiện tại và lưu chúng vào `dsi->commands`.
Vị trí lỗ hổng (netatalk-3.1.11-source/libatalk/dsi/dsi_opensess.c)
```C
memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```
Lỗ hổng nằm ở hàm `memcpy` trong `dsi_opensession`, hàm này **không giới hạn số byte được sao chép**. `dsi->commands[i]` có kiểu `uint8` và kích thước của nó do người dùng kiểm soát, có thể sao chép tối đa 255 byte. Tuy nhiên, `dsi->attn_quantum` có kiểu `uint32`, chỉ chiếm 4 byte. Lỗi tràn này có thể **ghi đè lên các trường tiếp theo** trong cấu trúc DSI, và nội dung của `dsi->commands+i+1` cũng do người dùng kiểm soát. Điều này có nghĩa là chúng ta có thể kiểm soát các trường trong cấu trúc DSI thông qua việc gây tràn.
Trường quan trọng nhất trong số này tất nhiên là con trỏ `commands`. Ghi đè nó bằng nội dung tùy ý cho phép hàm `dsi_stream_receive` đọc các tin nhắn từ đầu ra `dsi->commands`, cho chúng ta cơ hội **ghi vào một địa chỉ tùy ý (Arbitrary Address Write)**. Lưu ý rằng chúng ta cần gửi hai tin nhắn DSI đến cùng một socket để thực hiện điều này: tin nhắn đầu tiên ghi đè con trỏ `commands` bằng địa chỉ mục tiêu; tin nhắn thứ hai ghi nội dung tùy ý vào con trỏ `commands` đó.

#### Struct DSI:
/home/ngobao259/study_pwn/CVE-2018-1160/netatalk-3.1.11-source/include/atalk/dsi.h
```C
typedef struct DSI {
	...
    uint32_t attn_quantum, datasize, server_quantum;

    uint16_t serverID, clientID;

    uint8_t  *commands; /* DSI recieve buffer */  
	...
```
**uint32_t:** 
- Đây là kiểu **unsigned 32-bit integer** (số nguyên không dấu 32 bit).
- Dùng để lưu trữ số nguyên từ **0 → 4,294,967,295 (2³² - 1)**.
**uint16_t**
- Đây là kiểu **unsigned 16-bit integer** (số nguyên không dấu 16 bit).
- Dùng để lưu trữ số nguyên từ **0 → 65,535 (2¹⁶ - 1)**.
**uint8_t**
- Đây là kiểu **unsigned 8-bit integer** (số nguyên không dấu 8 bit).
- Dùng để lưu trữ số nguyên từ **0 → 255 (2⁸ - 1)**.
**uint8_t *commands**
- Đây là **con trỏ** trỏ đến vùng nhớ kiểu `uint8_t`, tức là một **mảng các byte**.
- Trong comment bạn ghi: `/* DSI receive buffer */`, có nghĩa `commands` là **buffer để nhận dữ liệu DSI** từ socket/network.
- Nói cách khác, đây là nơi lưu **payload/command từ client gửi đến server**.
#### Vị trí bị lỗi:
```C
/* OpenSession. set up the connection */

void dsi_opensession(DSI *dsi)

{

  uint32_t i = 0; /* this serves double duty. it must be 4-bytes long */

  int offs;

  

  if (setnonblock(dsi->socket, 1) < 0) {

      LOG(log_error, logtype_dsi, "dsi_opensession: setnonblock: %s", strerror(errno));

      AFP_PANIC("setnonblock error");

  }

  

  /* parse options */

  while (i < dsi->cmdlen) {

    switch (dsi->commands[i++]) {

    case DSIOPT_ATTNQUANT:

      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);

      dsi->attn_quantum = ntohl(dsi->attn_quantum);

  

    case DSIOPT_SERVQUANT: /* just ignore these */

    default:

      i += dsi->commands[i] + 1; /* forward past length tag + length */

      break;

    }

  }
```

Hàm này xử lý các message trong struct DSI. Nếu `commands[0]` có giá trị `DSIOPT_ATTNQUANT`, hàm sẽ gọi [[memcpy()]] sao chép `commands[1]` byte từ `commands[2]` vào trường `attn_quantum` của struct — đây chính là chỗ có lỗi.
*Ghi chú:* lỗi ở chỗ dùng chiều dài do client cung cấp (`dsi->commands[i]`) làm kích thước `memcpy` mà không kiểm tra giới hạn, nên có thể ghi tràn vào các trường liền kề trong struct `DSI`.
##### Nguyên lý lỗ hổng
Lỗ hổng nằm ở chỗ `dsi_opensession` gọi `memcpy` mà không kiểm tra giới hạn số byte được copy. Cụ thể:
- `dsi->commands[i]` có kiểu `uint8_t` và do client điều khiển, nên giá trị này tối đa là 255 (byte).
- `dsi->attn_quantum` là `uint32_t` chỉ chiếm 4 byte. Nếu copy nhiều hơn 4 byte sẽ ghi tràn và đè các trường tiếp theo trong struct `DSI`.
- Dữ liệu nguồn `dsi->commands + i + 1` cũng do client điều khiển, nên attacker có thể điều chỉnh nội dung được ghi lên các trường bị đè.
Vị trí lỗ hổng (netatalk-3.1.11-source/libatalk/dsi/dsi_opensess.c)
```C
memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```
Trong các trường bị ghi chồng lên, **quan trọng nhất là con trỏ `commands`** — nếu ta ghi đè thành một địa chỉ tùy ý, thì khi hàm `dsi_stream_receive` tiếp tục đọc dữ liệu vào `dsi->commands`, chương trình sẽ thực hiện ghi dữ liệu từ mạng vào địa chỉ mà ta đã đặt. Nói cách khác: ta có **một phép ghi tới địa chỉ bất kỳ** (arbitrary write).
Cần lưu ý: để hoàn thành arbitrary write này phải gửi **hai** thông điệp DSI trên **cùng một socket**:
1. Gửi thông điệp đầu tiên để **ghi đè `commands`** bằng địa chỉ đích mong muốn.
2. Gửi thông điệp thứ hai để **viết dữ liệu** vào địa chỉ được `commands` trỏ tới.
#### Rò rỉ địa chỉ (Leaking addresses)

Lỗ hổng cho phép **arbitrary write** nhưng viết vào GOT là không khả thi vì chương trình bật **RELRO**. Ta nghĩ đến `__free_hook` nhưng để ghi được vào đó cần **lộ (leak)** địa chỉ `libc` trước — tiếc là chương trình không có lỗi cho phép leak trực tiếp.

##### Ý tưởng tận dụng fork + sao chép không gian nhớ

Vì đây là dạng _webserver_, mỗi kết nối TCP đều `fork()` ra một tiến trình con để giao tiếp với client. Tiến trình con được tạo ra bằng cách copy không gian nhớ của tiến trình cha — tức là các vùng nhớ (addresses) trong tiến trình con **giống hệt** tiến trình cha (trong cùng một lần chạy server). Do đó ta có thể dùng phương pháp _bruteforce_ (bắn dò) để đoán địa chỉ: nếu tiến trình con bị crash thì server đơn giản fork lại một tiến trình con mới với cùng bố cục địa chỉ, ta lại thử tiếp. Nói cách khác: exploit lợi dụng việc ASLR của server **không đủ ngẫu nhiên**.

ASLR không hoàn toàn ngẫu nhiên (insufficient entropy) mở ra khả năng dò địa chỉ (bruteforce). Vậy ta có thể dò được gì?
##### Tìm offset của các hàm quan trọng:
```bash
readelf -s libc.so.6 | grep system
readelf -s libc.so.6 | grep execve
readelf -s libc.so.6 | grep puts
```
##### Khi exploit, em sẽ leak một địa chỉ (ví dụ địa chỉ `puts` trong GOT) → tính ra **base address của libc**:
```bash
libc_base = leaked_puts - offset_puts
```
=> Từ `libc_base`, cộng offset của `system`, `/bin/sh`, hoặc ROP gadget để dùng.
main -> puts@PLT -> [puts@GOT] -> libc:puts()
#### Tại sao hacker quan tâm?
- **Leak libc**:  
    Nếu ta gọi `puts(puts@GOT)`, chương trình sẽ in ra nội dung của GOT entry = địa chỉ `puts` thật trong libc.  
    → Tính được `libc_base`.
- **Ghi đè GOT** (nếu có quyền ghi):  
    Nếu binary cho phép `write@plt` hoặc `printf` format string → ghi đè `exit@GOT` thành `system` → khi chương trình gọi `exit`, nó thực chất gọi `system`.


References:
https://www.cnblogs.com/z5onk0/p/18295688

