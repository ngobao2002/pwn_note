## Recon
### Checksec
![[Pasted image 20251005145503.png]]
Như ta thấy, cơ chế bảo vệ duy nhất được bật là **NX (Non-eXecutable)**, nghĩa là vùng nhớ stack không thể thực thi.

### Code explaination
``` Assembly
; Attributes: bp-based frame

; int __cdecl main(int argc, const char **argv, const char **envp)
public main
main proc near

buf= byte ptr -10h

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 10h
mov     edi, 3          ; seconds
mov     eax, 0
call    _sleep
lea     rax, [rbp+buf]
mov     edx, 100h       ; nbytes
mov     rsi, rax        ; buf
mov     edi, 0          ; fd
mov     eax, 0
call    _read
leave
retn
; } // starts at 400544
main endp
```

Pseudo code:
```C
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf[16]; // [rsp+0h] [rbp-10h] BYREF

  sleep(3u);
  return read(0, buf, 0x100uLL);
}
```
Đây là một chương trình đơn giản nhưng chứa 1 lỗ hổng stack overflow nghiêm trọng, sau khi chương trình sleep 3s sẽ cho đọc 256 bytes(0x100) nhưng chỉ cung cấp 1 buffer 16 bytes. 
Điều này có thể gây
- **Stack overflow**: Ghi đè dữ liệu trên stack
- **Control flow hijacking**: Có thể ghi đè return address
- **Code execution**: Khai thác để thực thi shellcode
Vì không có stack canary. chúng ta có thể chiếm quyền điều khiển luồng thực thi (hijack program control) mà không cần bất kì kĩ thuật leak thông tin nào.
Thoạt nhìn đây là 1 file binary đơn giản có khá ít "nguyên liệu" để có thể gọi shell.
Khi tôi kiểm tra các hàm trong file này với lệnh info function trong pwndbg:
![[Pasted image 20251005152804.png]]

Tôi thấy được hàm `__libc_csu_init()` với việc vừa được học kĩ thuật [[ret2csu]] tôi quyết định sẽ thử tận dụng các gadget có sẵn trong hàm này để gọi shell
##### Lưu ý: 
Lưu ý rằng kỹ thuật này không còn hoạt động trên các phiên bản glibc mới hơn, vì từ glibc 2.34, hàm này đã được chuyển vào bên trong libc với tên `call_init`

Vấn đề tiếp theo của chúng ta là không có sẵn gadget `syscall`, và cũng không có cách nào rõ ràng để kiểm soát thanh ghi `rax` về giá trị mong muốn là 59 (mã của `execve`).
Theo quy ước của ABI x86_64, thanh ghi `ax` (và các dạng mở rộng của nó) có nhiều công dụng. Một trong số đó là chứa giá trị trả về của mỗi hàm được thực thi. Nếu có thể chiếm quyền điều khiển luồng chương trình, chúng ta có thể điền bất kỳ giá trị nào vào `rax` chỉ bằng cách thao túng chức năng này.