### Write-What-Where primitive
- **Định nghĩa:** khả năng **ghi một giá trị tùy ý (what)** vào **vị trí bộ nhớ tùy ý (where)**.
- **Ý nghĩa:** đây là primitive rất mạnh vì nếu attacker biết địa chỉ `where` (ví dụ GOT entry, function pointer, hook) và có `what` (ví dụ địa chỉ `system`), họ có thể redirect execution.
- **So sánh:** tương tự format-string `write` (ví dụ `%n`) nhưng xuất hiện trong exploit heap khi bạn lệch các con trỏ/metadata để làm allocator ghi dữ liệu do bạn điều khiển vào địa chỉ mong muốn.
### Các “where” thường được nhắm tới
#### Fini-array
- **Fini-array** chứa các con trỏ tới hàm được gọi khi chương trình thoát (exit). Viết lên đó có thể làm hàm khác (do attacker chọn) được gọi khi chương trình kết thúc.
- **RELRO (Partial Relro)**: Khi **partial RELRO** được bật, một số sections (như GOT dynamic relocations) **không** bị khóa hoàn toàn — Fini-array có thể **không** ở vùng readonly, vẫn có khả năng viết tùy môi trường/binary.
- Thực tế: target Fini-array hữu ích nếu bạn muốn execution xảy ra ở `exit()` hoặc tương tự.
#### GOT (Global Offset Table)
- GOT chứa địa chỉ runtime của các hàm external (ví dụ `puts`, `system` khi dynamic). Overwrite GOT entry = redirect gọi hàm đó sang địa chỉ mong muốn.
- **Full RELRO**: khi bật `-z relro` + `-z now` (full RELRO) thì GOT **được đặt read-only sau dynamic linking**, nên **không** thể overwrite ở runtime => GOT khai thác bị chặn.
- **Partial RELRO**: GOT vẫn writable cho một số entry, dễ bị overwrite.
#### Hooks (glibc malloc hooks)
- Trước đây glibc có các hook như `__malloc_hook`, `__free_hook`, `__realloc_hook` — attacker có thể overwrite hook để khi gọi malloc/free dẫn tới execution.
- Tới gần đây (glibc 2.34) các hook này **bị loại bỏ hoặc không còn hỗ trợ** theo cùng cách, nên exploit dựa vào hook càng ngày càng khó (và patch/library khác nhau có status khác nhau).
- **Lưu ý:** tùy phiên bản glibc/mapped libc, tên và tồn tại của hook khác nhau — exploit phải kiểm tra target environment.
### “What to write” — Viết gì vào đâu?
Đây là ví dụ các giá trị thường viết vào `where` để thực thi mã:
#### `system()` (viết địa chỉ `system` vào entry hàm)
- Ý tưởng: overwrite một function pointer (hoặc GOT entry của `puts`/`printf`) thành địa chỉ `system`. Sau đó khi chương trình gọi hàm đó với tham số attacker kiểm soát (ví dụ chuỗi `"sh"` hoặc `"/bin/sh"`), `system("/bin/sh")` được gọi và attacker có shell.
- Thường cần leak địa chỉ libc để compute địa chỉ `system` tương ứng (ASLR).
#### One-Gadget
- **One-gadget** là một gadget trong libc (thường được tìm bằng `one_gadget` tool) — một offset tới nơi trong libc mà nếu register / stack thỏa một số điều kiện (ví dụ một số thanh ghi NULL), một `execve("/bin/sh", NULL, NULL)` hoặc tương tự sẽ xảy ra ngay lập tức.
	- Khác với `system`, one-gadget bỏ qua việc gọi `system` với argument; nó là entry point sẵn sàng tạo shell nếu state register/stack phù hợp.
- One-gadget mạnh nhưng **rất** nhạy với điều kiện: bạn cần đảm bảo các register hoặc bộ nhớ trống theo điều kiện gadget yêu cầu. Do đó exploit phải set up state phù hợp (thường khó hơn nhưng rất hiệu quả nếu đạt được).
References:
https://pwn.umasscybersec.org